\documentclass{article}
\usepackage[a4paper, margin=2cm]{geometry}
\usepackage{algorithm}
\usepackage{algpseudocode}
\begin{document}


% RWMH
\begin{algorithm}
\caption{RWMH}
\label{alg_rwmh}
\begin{algorithmic}
\For{$\textrm{step} \gets 1 \ldots n_\textrm{samples}$} \Comment{generate $n_\textrm{samples}$ from target distribution}
	\State resample $\theta' \sim N(\theta, \sigma^2)$ \Comment{propose new parameters}
	\State with prob. $\min{(1, \frac{\pi(\theta')}{\pi(\theta)})}$, set $\theta \gets \theta'$ \Comment{accept / reject the proposal}
\EndFor
\end{algorithmic}
\end{algorithm}


% leapfrog
\begin{algorithm}
\caption{Leapfrog}
\label{alg_leapfrog}
\begin{algorithmic}
\For{$i \gets 1 \ldots n_\mathrm{steps}$} \Comment{do $n_\mathrm{steps}$ steps}
\State $v \gets v - \frac{\varepsilon}{2} \frac{\partial U}{\partial \theta}$ \Comment{do a half-step update of momentum}
\State $\theta \gets \theta + v$ \Comment{do a full-step update of parameters}
\State $v \gets v - \frac{\varepsilon}{2} \frac{\partial U}{\partial \theta}$ \Comment{do a half-step update of momentum}
\EndFor
\end{algorithmic}
\end{algorithm}


% HMC
\begin{algorithm}
\caption{HMC}
\label{alg_hmc}
\begin{algorithmic}
\For{$\textrm{step} \gets 1 \ldots n_\textrm{samples}$} \Comment{generate $n_\textrm{samples}$ from target distribution}
	\State resample $v \sim N(0, \sigma^2)$ \Comment{resample momentum}
	\State $\theta', v' \gets \textrm{Leapfrog}(\theta, v)$ \Comment{propose new parameters}
	\State with prob. $\min{\left(1, \frac{\pi(\theta')}{\pi(\theta)} \exp \left( \frac{1}{2}||v||^2 - ||v'||^2 \right) \right)}$, set $\theta \gets \theta'$ \Comment{accept / reject the proposal}
\EndFor
\end{algorithmic}
\end{algorithm}


% NUTS
\begin{algorithm}
\caption{Iterative NUTS}
\label{alg_nuts}
\begin{algorithmic}
\For{$\textrm{step} \gets 1 \ldots n_\textrm{samples}$} \Comment{generate $n_\textrm{samples}$ from target distribution}
	\State $\textrm{checkpoints}[0] = (\theta, v)$ \Comment{checkpoint first leaf}
	\State $\theta^+, \theta^-, \theta_\textrm{out} \gets \theta $ \Comment{initialize leftmost ($-$) and rightmost ($+$) leaf}
	\State $v^+, v^-, v_\textrm{out} \gets v $
	\State $n_\textrm{valid leafs} \gets 1$ \Comment{size of $\mathcal{C}$}
	\State resample $\log u \sim \log \pi(\theta, v) - \textrm{Exp}(1)$ \Comment{resample log of slice variable}
	
	\State $\textrm{stop} \gets \textrm{False}$
	\State resample $v \sim N(0, \sigma^2)$ \Comment{resample momentum}
	\For{$i \gets 1 \ldots 2^\textrm{MaxTreeHeight}$} \Comment{loop through leafs}
		
		% tree has doubled
		\If{$\textrm{IsPowerOfTwo}(i)$} \Comment{tree is about to double}
			\State $\theta_\textrm{out}, v_\textrm{out} \gets \theta_\textrm{subtree out}, v_\textrm{subtree out}$ \Comment{leafs are valid only if there were no U-turns}
			\State resample $\textrm{direction}_\textrm{new} \sim \textrm{Uniform}[\{-1, 1\}]$ \Comment{decide whether to leapfrog forwards or backwards}
			\If{$\textrm{direction}_\textrm{new} \ne \textrm{direction}$} \Comment{when direction changes, the tree needs to be flipped}
				\State $\theta^+, \theta^- \gets \theta^-, \theta^+$
				\State $v^+, v^- \gets v^-, v^+$
			\EndIf
			\State $\textrm{direction} \gets \textrm{direction}_\textrm{new}$
		\EndIf
		
		% leapfrog
		\State $\theta^+, v^+ \gets \textrm{Leapfrog}(\theta^+, v^+, \textrm{direction})$ \Comment{leapfrog a single step (forwards or backwards in time)}
		
		% update chekpoints
		\If{$i$ is even} \Comment{update checkpoints}
			\State $\textrm{checkpoints}[\textrm{BitCount}(i)] = (\theta, v)$
		
		% check u-turns
		\ElsIf{$i$ is odd} \Comment{check U-turns}
			\For{$j \gets \textrm{BitCount}(i)-\textrm{NumTrailingBits}(i) \ldots \textrm{NumTrailingBits}(i)$}
				\State $\theta^*, v^* \gets \textrm{checkpoints}[j]$
				\State $\textrm{stop} \gets \textrm{stop} \ \textrm{or} \ (\theta^+ - \theta^*) \cdot v^* < 0 \ \textrm{or} \ (\theta^+ - \theta^*) \cdot v^+ < 0$
		    \EndFor
		\EndIf
		
		% check max error
		\State $\textrm{stop} \gets \textrm{stop} \ \textrm{or} \ \Delta_\mathrm{max} < \log u - \log \pi(\theta^+, v^+)$ \Comment{check maximum leapfrog error}
			
		% update output
		\If{stop}
			\State $\theta, v \gets \theta_\textrm{out}, v_\textrm{out}$ \Comment{$\theta_\textrm{out}, v_\textrm{out}$ were sampled uniformly among the valid leafs}
			\State break
		\Else
			\If{$u \leq \pi(\theta^+, v^+)$} \Comment{slice sampling}
				\State with prob. $1/n_\textrm{valid leafs}$, set $\theta_\textrm{subtree out}, v_\textrm{subtree out} \gets \theta^+, v^+$ \Comment{resample output leaf}
				\State $n_\textrm{valid leafs} \gets n_\textrm{valid leafs} + 1$
			\EndIf
		\EndIf
		
	\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}


\end{document}
